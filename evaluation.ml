(* 
                         CS 51 Final Project
                         MiniML -- Evaluation
*)

(* This module implements a small untyped ML-like language under
   various operational semantics.
 *)

open Expr ;;
  
(* Exception for evaluator runtime, generated by a runtime error in
   the interpreter *)
exception EvalError of string ;;
  
(* Exception for evaluator runtime, generated by an explicit `raise`
   construct in the object language *)
exception EvalException ;;

(*......................................................................
  Environments and values 
 *)

module type ENV = sig
    (* the type of environments *)
    type env
    (* the type of values stored in environments *)
    type value =
      | Val of expr
      | Closure of (expr * env)
   
    (* empty () -- Returns an empty environment *)
    val empty : unit -> env

    (* close expr env -- Returns a closure for `expr` and its `env` *)
    val close : expr -> env -> value

    (* lookup env varid -- Returns the value in the `env` for the
       `varid`, raising an `Eval_error` if not found *)
    val lookup : env -> varid -> value

    (* extend env varid loc -- Returns a new environment just like
       `env` except that it maps the variable `varid` to the `value`
       stored at `loc`. This allows later changing the value, an
       ability used in the evaluation of `letrec`. To make good on
       this, extending an environment needs to preserve the previous
       bindings in a physical, not just structural, way. *)
    val extend : env -> varid -> value ref -> env

    (* env_to_string env -- Returns a printable string representation
       of environment `env` *)
    val env_to_string : env -> string
                                 
    (* value_to_string ?printenvp value -- Returns a printable string
       representation of a value; the optional flag `printenvp`
       (default: `true`) determines whether to include the environment
       in the string representation when called on a closure *)
    val value_to_string : ?printenvp:bool -> value -> string

    val env_lookup_tester : unit -> unit 

    val env_extend_tester : unit -> unit

  end

module Env : ENV =
  struct
    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    let empty () : env = []

    let close (exp : expr) (env : env) : value =
      Closure (exp, env)

    let lookup (env : env) (varname : varid) : value =
      try !(List.assoc varname env)
      with Not_found -> raise (EvalError "Varid in Env not found")

    let extend (env : env) (varname : varid) (loc : value ref) : env =
      List.remove_assoc varname env @ [varname, loc] 

    let rec value_to_string ?(printenvp : bool = true) (v : value) : string =
      match v with 
      | Val exp -> exp_to_concrete_string exp
      | Closure (exp, env) -> "[" ^ (if printenvp then env_to_string env ^ " âŠ¢ " 
                                    else "")  ^ exp_to_concrete_string exp ^ "]"

    and env_to_string (env : env) : string =
      let env_string = "" in 
      let rec helper (env: env) (str: string) : string =  
        match env with 
        | (var, v) :: tl -> var ^ " -> " ^ value_to_string !v ^ 
                            (if tl = [] then "" else "; " ^ helper tl str) 
        | [] -> ""  
      in "{" ^ helper env env_string ^ "}"

      let env_lookup_tester () =  
        let e = empty () in 
        (*assert (lookup e "x" = raise (EvalError "Varid in Env not found"));*)
        let e = ["x", ref (close (Fun("y", Var("x"))) (empty()))] in 
        assert (lookup e "x" = (close (Fun("y", Var("x"))) (empty())));
        (*let e = ["x", ref (close (Fun("y", Var("x"))) (empty()))] in 
        assert (lookup e "y" = raise (EvalError "Varid in Env not found"));*)
        let e = ["x", ref (close (Fun("y", Var("x"))) (empty()));
                 "y", ref (Val(Num(4)))] in 
        assert (lookup e "y" = (Val(Num(4))))

      let env_extend_tester () = 
        let e = empty () in 
        let e = extend e "x" (ref (Val(Num(42)))) in 
        assert (e = ["x", (ref (Val(Num(42))))]);
        let e = extend e "x" (ref (close (Fun("y", Var("x"))) (empty()))) in 
        assert (e = ["x", (ref (close (Fun("y", Var("x"))) (empty())))]); 
        let e = extend e "y" (ref (close (Fun("y", Var("x"))) (empty()))) in 
        assert (e = ["x", (ref (close (Fun("y", Var("x"))) (empty()))); 
                    "y", (ref (close (Fun("y", Var("x"))) (empty())))]); 
        let e = extend e "z" (ref (Val(Let("x", Binop(Times, Var("y"), 
                              Var("y")), Binop(Plus, Var("x"), Var("x")))))) in 
        assert (e = ["x", (ref (close (Fun("y", Var("x"))) (empty()))); 
                    "y", (ref (close (Fun("y", Var("x"))) (empty()))); 
                    "z", (ref (Val(Let("x", Binop(Times, Var("y"), Var("y")), 
                              Binop(Plus, Var("x"), Var("x"))))))])
  end
;;

(* coerce the expr, unchanged, into a value *)
 let eval_t (exp : expr) (_env : Env.env) : Env.value =
  Env.Val exp ;;

let rec eval_h (exp: expr) (env: Env.env) (eval_type: int): expr = 
  match exp with 
  | Num _ | Bool _ | Float _ -> exp
  | Unop (u, e) -> (match u, eval_h e env eval_type, eval_type with 
                   | Negate, Num num, _ -> Num(~-num)
                   | Negate, Float f, _ -> Float (~-.f)
                   | Deref, Unop(Ref, expr), 3 -> expr
                   | Ref, expr, 3 -> Unop(Ref, expr) 
                   | _ -> raise (EvalError "Unop"))

  | Binop (b, e1, e2) -> (match b, (eval_h e1 env eval_type), 
                                   (eval_h e2 env eval_type), eval_type with  
                         | Equals, Num p, Num q, _ -> Bool (p = q)
                         | Equals, Bool p, Bool q, _ -> Bool (p = q)
                         | LessThan, Num p, Num q, _ -> Bool (p < q)
                         | LessThan, Bool p, Bool q, _ -> Bool (p < q)
                         | Plus, Num p, Num q, _ -> Num (p + q)
                         | Plus, Float p, Float q, _ -> Float (p +. q)
                         | Minus, Num p, Num q, _ -> Num (p - q)
                         | Minus, Float p, Float q, _ -> Float (p -. q)
                         | Times, Num p, Num q, _ -> Num (p * q) 
                         | Times, Float p, Float q, _ -> Float (p *. q)
                         | Divide, Num p, Num q, _ -> Num (p / q)
                         | Divide, Float p, Float q, _ -> Float (p /. q)
                         | Assign, Unop(Ref, Float _), Float _, 3 -> Unit
                         | Assign, Unop(Ref, Num _), Num _, 3 -> Unit
                         | Assign, Unop(Ref, Bool _), Bool _, 3 -> Unit
                         | _ -> raise (EvalError "Binop"))                          
  | Conditional (e1, e2, e3) -> (match eval_h e1 env eval_type with 
                                | Bool cond -> if cond 
                                               then eval_h e2 env eval_type 
                                               else eval_h e3 env eval_type
                                | _ -> raise (EvalError "Conditional"))
  | Raise | Unassigned -> raise (EvalError "Unrecognized expression") 
  | Unit -> exp
  | _ -> if eval_type = 1 then 
          (match eval_s exp env with 
          | Env.Val v -> v 
          | _ -> raise (EvalError "Non-closure"))
         else if eval_type = 2 then 
          (match eval_d exp env with 
          | Env.Val v -> v 
          | _ -> raise (EvalError "Non-closure"))
         else if eval_type = 3 then 
          (match eval_l exp env with 
          | Env.Val v -> v 
          | _ -> raise (EvalError "Non-closure"))
         else raise (EvalError "Input correct evaluation")

and eval_s (exp : expr) (_env : Env.env) : Env.value =
  let rec eval_h_s (exp : expr): expr = 
  match exp with 
  | Var _ -> raise (EvalError "Unbound Variable")
  | Num _ | Bool _ | Unop _ | Binop _ | Conditional _ | Float _ 
  | Raise | Unassigned | Unit -> eval_h exp (Env.empty()) 1
  | Fun _ -> exp
  | Let (var, e1, e2) -> eval_h_s (subst var (eval_h_s e1) e2) 
  | Letrec (var, e1, e2) -> let v_d = eval_h_s e1 in 
                            eval_h_s (subst var 
                                     (eval_h_s 
                                     (subst var 
                                     (Letrec (var, v_d, Var var)) v_d)) e2) 
  | App (e1, e2) -> (match (eval_h_s e1), (eval_h_s e2) with
                    | Fun (var, e), expr -> eval_h_s (subst var expr e) 
                    | _ -> raise (EvalError "Function Application")) 
  in Env.Val (eval_h_s exp)
  
  and eval_d (exp : expr) (env : Env.env) : Env.value = 
  match exp with 
  | Num _ | Bool _ | Unop _ | Binop _ | Conditional _ | Float _
  | Raise | Unassigned | Unit -> Env.Val (eval_h exp env 2)
  | Var v -> Env.lookup env v
  | Fun (_, _) as exp -> Env.Val exp
  | Let (var, e1, e2)
  | Letrec (var, e1, e2) -> eval_d e2 (Env.extend env var (ref (eval_d e1 env)))
  | App (e1, e2) -> (match (eval_d e1 env), (eval_d e2 env) with
                    | Env.Val(Fun (var, e)), expr -> eval_d e 
                                                 (Env.extend env var (ref expr)) 
                    | _ -> raise (EvalError "Function Application"))
       
and eval_l (exp : expr) (env : Env.env) : Env.value =
  match exp with 
  | Num _ | Bool _ | Unop _ | Binop _ | Conditional _ | Float _
  | Raise | Unassigned | Unit -> Env.Val (eval_h exp env 3)
  | Var v -> Env.lookup env v
  | Fun (_, _) as exp -> Env.close exp env 
  | Let (var, e1, e2) -> (match e1 with 
                         | Binop (Assign, p, q) -> 
                            let temp = ref (eval_l p env) in 
                            (match !temp, p with 
                            | Env.Val (Unop (Ref, _)), Var v -> 
                                let env_x = Env.extend env v temp in 
                                temp := eval_l (Unop (Ref, q)) env_x; 
                                eval_l e2 (Env.extend env_x var 
                                          (ref (Env.Val(Unit)))) 
                            | Env.Val (Unop (Ref, _)), _ -> Env.Val(Unit) 
                            | _ -> raise (EvalError "Binop"))
                         | _ -> eval_l e2 (Env.extend env var 
                                          (ref (eval_l e1 env)))) 
  | Letrec (var, e1, e2) -> let temp = ref (Env.Val(Unassigned)) in 
                            let env_x = Env.extend env var temp
                            in temp := (eval_l e1 env_x); eval_l e2 env_x 
  | App (e1, e2) -> (match (eval_l e1 env), (eval_l e2 env) with
                    | Env.Closure (exp, c_env), value_d -> 
                        (match exp with 
                        | Fun (v, e) -> eval_l e (Env.extend c_env v (ref value_d))
                        | _ -> raise (EvalError "Function Application"))
                    | _ -> raise (EvalError "Function Application"))
  ;; 

  let eval_s_test () = 
    let e = Let("x", Num(1), 
                     Let("f", Fun("y", Binop(Plus, Var("x"), Var("y"))), 
                              Let("x", Num(2), App(Var("f"), Num(3))))) in
    assert (eval_s e (Env.empty()) = Env.Val(Num(4)));
    let e = App(Fun("x", Binop(Times, Var("x"), Var("x"))), 
                         Binop(Minus, Num(8), Num(2))) in 
    assert (eval_s e (Env.empty()) = Env.Val(Num(36)));
    let e = Let("x", Binop(Plus, Num(3), Num(5)), 
                     App(Fun("x", Binop(Times, Var("x"), Var("x"))), 
                                  Binop(Minus, Var("x"), Num(2)))) in 
    assert (eval_s e (Env.empty()) = Env.Val(Num(36)));
    let e = Let("x", Binop(Times, Num(2), Num(25)), 
                     Binop(Plus, Var("x"), Num(1))) in 
    assert (eval_s e (Env.empty()) = Env.Val(Num(51)));
    let e = Let("x", Binop(Plus, Num(3), Num(5)), 
                     App(Fun("x", Binop(Times, Var("x"), Var("x"))), 
                                  Binop(Minus, Var("x"), Num(2)))) in 
    assert (eval_s e (Env.empty()) = Env.Val(Num(36)));
    let e = Let("x", Num(51), Let("x", Num(124), Var("x"))) in 
    assert (eval_s e (Env.empty()) = Env.Val(Num(124)));
    let e = Let("x", Num(2), Let("f", Fun("y", Binop(Plus, Var("x"), Var("y"))), 
                                      Let("x", Num(8), 
                                               App(Var("f"), Var("x"))))) in 
    assert (eval_s e (Env.empty()) = Env.Val(Num(10)));
    let e = App(Fun("y", Binop(Plus, Var("y"), Var("y"))), Num(10)) in 
    assert (eval_s e (Env.empty()) = Env.Val(Num(20)));
    let e = Let("f", Fun("y", Binop(Plus, Var("y"), Var("y"))), 
                     App(Var("f"), Num(10))) in 
    assert (eval_s e (Env.empty()) = Env.Val(Num(20)));
    let e = Unit in 
    assert (eval_s e (Env.empty()) = Env.Val(Unit));
    let e = Letrec("f", Fun("n", 
                        Conditional(Binop(LessThan, Var("n"), Num(0)), Num(1), 
                                   Binop(Plus, Num(3), App(Var("f"), 
                                   Binop(Minus, Var("n"), Num(1)))))), 
                                                App(Var("f"), Num(4))) in 
    assert (eval_s e (Env.empty()) = Env.Val(Num(16)));
    let e = Letrec("f", Fun("n", 
                        Conditional(Binop(Equals, Var("n"), Num(0)), Num(1), 
                                   Binop(Times, Var("n"), App(Var("f"), 
                                   Binop(Minus, Var("n"), Num(1)))))), 
                        App(Var("f"), Num(12))) in 
    assert (eval_s e (Env.empty()) = Env.Val(Num(479001600)));
    let e = Let("x", Num(5), Binop(Divide, Var("x"), Num(2))) in 
    assert (eval_s e (Env.empty()) = Env.Val(Num(2)));
    let e = Let("x", Float(9.), Binop(Plus, Binop(Times, Float(2.), Var("x")), 
                                     Float(10.))) in 
    assert (eval_s e (Env.empty()) = Env.Val(Float(28.)));;
    (*let e = Let("x", Unop(Ref, Num(3)), Unop(Deref, Var("x"))) in 
    assert (eval_s e (Env.empty()) = raise (EvalError "Unop")) ;;*)
  
  let eval_d_test () = 
    let e = Let("x", Binop(Plus, Num(3), Num(5)), 
                     App(Fun("x", Binop(Times, Var("x"), Var("x"))), 
                                  Binop(Minus, Var("x"), Num(2)))) in 
    assert (eval_d e (Env.empty()) = Env.Val(Num(36)));
    let e = Let("x", Num(51), Let("x", Num(124), Var("x"))) in 
    assert (eval_d e (Env.empty()) = Env.Val(Num(124)));
    let e = Let("x", Num(2), Let("f", Fun("y", Binop(Plus, Var("x"), Var("y"))), 
                                      Let("x", Num(8), 
                                          App(Var("f"), Var("x"))))) in 
    assert (eval_d e (Env.empty()) = Env.Val(Num(16)));
    let e = Letrec("f", Fun("n", 
                        Conditional(Binop(LessThan, Var("n"), Num(0)), Num(1), 
                                    Binop(Plus, Num(3), App(Var("f"), 
                                                        Binop(Minus, Var("n"), 
                                                                     Num(1)))))), 
                        App(Var("f"), Num(4))) in 
    assert (eval_d e (Env.empty()) = Env.Val(Num(16)));
    let e = Letrec("f", Fun("n", 
                        Conditional(Binop(Equals, Var("n"), Num(0)), 
                                    Num(1), 
                                    Binop(Times, Var("n"), App(Var("f"), 
                                                           Binop(Minus, Var("n"), 
                                                                        Num(1)))))), 
                        App(Var("f"), Num(12))) in 
    assert (eval_d e (Env.empty()) = Env.Val(Num(479001600)));
    let e = Unit in 
    assert (eval_d e (Env.empty()) = Env.Val(Unit));
    let e = Let("x", Num(9), Binop(Plus, Num(4), Binop(Divide, Var("x"), Num(3)))) in 
    assert (eval_d e (Env.empty()) = Env.Val(Num(7)));
    let e = App(Fun("n", Binop(Minus, Float(9.), 
                Binop(Times, Var("n"), Float(15.)))), Float(12.)) in
    assert (eval_d e (Env.empty()) = Env.Val(Float(~-.171.)));;
    (*let e = Let("x", Unop(Ref, Num(3)), Unop(Deref, Var("x"))) in 
    assert (eval_s e (Env.empty()) = raise (EvalError "Unop")) ;;*)
  
  let eval_l_test () = 
    let e = Let("x", Num(1), 
                     Let("f", Fun("y", Binop(Plus, Var("x"), Var("y"))), 
                                  Let("x", Num(2), App(Var("f"), Num(3))))) in
    assert (eval_l e (Env.empty()) = Env.Val(Num(4)));
    let e = App(Fun("x", Binop(Times, Var("x"), Var("x"))), 
                Binop(Minus, Num(8), Num(2))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(36)));
    let e = Let("x", Binop(Plus, Num(3), Num(5)), 
                App(Fun("x", Binop(Times, Var("x"),
                    Var("x"))), Binop(Minus, Var("x"), Num(2)))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(36)));
    let e = Let("x", Binop(Times, Num(2), Num(25)), 
                     Binop(Plus, Var("x"), Num(1))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(51)));
    let e = Let("x", Binop(Plus, Num(3), Num(5)), 
                     App(Fun("x", Binop(Times, Var("x"), Var("x"))), 
                         Binop(Minus, Var("x"), Num(2)))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(36)));
    let e = Let("x", Num(51), Let("x", Num(124), Var("x"))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(124)));
    let e = Let("x", Num(2), Let("f", Fun("y", Binop(Plus, Var("x"), Var("y"))), 
                              Let("x", Num(8), App(Var("f"), Var("x"))))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(10)));
    let e = App(Fun("y", Binop(Plus, Var("y"), Var("y"))), Num(10)) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(20)));
    let e = Let("f", Fun("y", Binop(Plus, Var("y"), Var("y"))), 
                App(Var("f"), Num(10))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(20)));
    let e = Unit in 
    assert (eval_l e (Env.empty()) = Env.Val(Unit));
    let e = Let("x", Unop(Ref, Num(3)), Unop(Deref, Var("x"))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(3))); 
    let e = Let("x", Unop(Ref, Num(42)), 
                Let("y", Binop(Assign, Var("x"), 
                              Binop(Minus, Unop(Deref, Var("x")), Num(21))), 
                    Binop(Plus, Unop(Deref, Var("x")), Unop(Deref, Var("x"))))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(42))); 
    let e = Let("x", Unop(Ref, Unop(Ref, Num(3))), 
                Let("y", Unop(Deref, Var("x")), 
                   Let("z", Binop(Assign, Var("y"), 
                      Binop(Plus, Unop(Deref, Unop(Deref, Var("x"))), 
                            Unop(Deref, Var("y")))), Unop(Deref, Var("y"))))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(6))); 
    let e = Let("x", Unop(Ref, Num(3)), 
                Let("y", Binop(Assign, Var("x"), Num(3)), Var("y"))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Unit));
    let e = Letrec("f", Fun("n", 
                  Conditional(Binop(Equals, Var("n"), Num(0)), 
                              Num(1), 
                              Binop(Times, Var("n"), App(Var("f"), 
                                                     Binop(Minus, Var("n"), Num(1)))))), 
                                                     App(Var("f"), Num(5))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(120)));
    let e = Letrec("f", Fun("n", 
                  Conditional(Binop(LessThan, Var("n"), Num(0)), 
                              Num(1), Binop(Plus, Num(3), App(Var("f"), 
                                      Binop(Minus, Var("n"), Num(1)))))), 
                                      App(Var("f"), Num(4))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(16)));
    let e = Letrec("f", Fun("n", 
                        Conditional(Binop(LessThan, Unop(Deref, Var("n")), Num(0)), 
                                   Num(1), Binop(Plus, Num(3), App(Var("f"), 
                                           Unop(Ref, Binop(Minus, Unop(Deref, Var("n")), 
                                           Num(1))))))), App(Var("f"), 
                                           Unop(Ref, Num(4)))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(16)));
    let e = Letrec("f", Fun("n", 
            Conditional(Binop(Equals, Unop(Deref, Var("n")), Num(0)), 
                        Num(1), Let("y", Binop(Assign, Var("n"), 
                        Binop(Minus, Unop(Deref, Var("n")), Num(1))), App(Var("f"), 
                        Var("n"))))), App(Var("f"), Unop(Ref, Num(5)))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(1)));
    let e = Let("x", Num(7), Binop(Divide, Binop(Times, Num(4), Var("x")), Num(3))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Num(9)));
    let e = Let("x", Unop(Ref, Float(7.)), 
                Let("y", Binop(Assign, Var("x"), 
                    Binop(Plus, Unop(Deref, Var("x")), Float(16.))), 
                                Unop(Deref, Var("x")))) in 
    assert (eval_l e (Env.empty()) = Env.Val(Float(23.)));;

    
  let run_tests () = 
    eval_s_test ();
    eval_d_test ();
    eval_l_test ()  


(* The EXTENDED evaluator -- if you want, you can provide your
   extension as a separate evaluator, or if it is type- and
   correctness-compatible with one of the above, you can incorporate
   your extensions within `eval_s`, `eval_d`, or `eval_l`. *)

let eval_e _ =
  failwith "eval_e not implemented" ;;
  
(* Connecting the evaluators to the external world. The REPL in
   `miniml.ml` uses a call to the single function `evaluate` defined
   here. Initially, `evaluate` is the trivial evaluator `eval_t`. But
   you can define it to use any of the other evaluators as you proceed
   to implement them. (We will directly unit test the four evaluators
   above, not the `evaluate` function, so it doesn't matter how it's
   set when you submit your solution.) *)
   
let evaluate = eval_t ;;